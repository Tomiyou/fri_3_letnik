For the first part of the problem we decided to use simulated annealing approach to local search. Our first approach to a neighborhood generation function we tried to make it completely rnadom, such that didn't care for constraints and could even create paths that were impossible in the graph, but just made random modifications to the current configuration. To still enforce the constraints, the cost function severely punishes the solutions that do not satisfy the constraints. After some testing, we realized that the chance to change a path for one truck should be fairly low, as otherwise the change in the neighborhood was too large and simulated annealing often discarded the solution, thought it might lead to a better overall solution down the road. This completely random approach was severly limiting on the last few problems, since they are noticeably bigger. Even with a high iteration count before reducing temperature, the algorithm usually was unable to find a solution that satisfied all the constraints. After this realization, we tried many different things, from creating a function that would try to fix paths that were impossible, to starting with a path that did satisfy all constraints but still kept a completely randomized neighborhood function. We also tried finding impossible connections in each path and changing them randomly to hopefully stumble upon a possible one. In the end we went with a cost function that would severly punish paths that weren't possible/didn't satisfy constraints and a neighborhood function that made 

Za resevanje problema z lokalnim preiskovanjem sva uporabila simulirano ohlajanje. Kot prvo idejo sva imela, da bi uporabila popolnoma naključno generiranje soseske. Funkcija se sploh ne bi menila za kakrsne koli omejitve ali pravilnosti poti, ampak bi preprosto samo popolnoma naključno rahlo spremenila soseko, tako da bi naključno dodala, odvzela ali spremenila vozlišče v poti. Vse kršitve omejitev bi močno kaznovala v funkciji ocenjevanja kvalitete, tako da bi sčasoma med rešitvami ostale samo rešitve, ki upoštevajo pravila. Ideja je bila, da tak naključni algoritem ne bi padel v lokalni optimum tako hitro, kot npr. požrešno iskanje. Tako sva najprej z neko verjetnostjo naključno spremenila pot vsakega tovornjaka. Hitro se je izkazalo, da mora biti ta verjetnost precej nizka (< %5), saj so večje verjetnosti močno spremenile soseko in s tem tudi njeno oceno kvalitete, lokalno preiskovanje pa potrebuje manjše razlike v soseski, da najde boljše rešitve (poznalo se je tudi na rezultatih). Prvih par primer je dobro delovalo že s tako preprostim algoritmom, če sva malo dvignila število iteracij in dala algoritmu več časa, da najde kakšno boljšo rešitev. Problemi, so nastali, ko sva prišla do daljših problemov, saj je algoritem preveč časa porabil z izločanjem povezav, ki ne obstajajo iz naključne postavitve poti, kot pa da bi iskal izboljšave poti (saj so bile spremembe res naključne, ne pa tam, kjer so bile problematične povezave). Z večanjem števila iteracij, je število povezav v rešitvi, ki ne obstajajo, seveda padalo, ampak nikoli ni prišlo do 0. Tako sva poskusila namesto popolnoma naključne soseke, z neko verjetnostjo dodajati/spreminjati vozlišča, ki so sosedi vozlišč, ki so že v poti. Da bi še bolj zmanjšala iskanje teh dejanskih poti, sva namesto naključne začetne poti, preprosto vzela naključno zaporedje sosedov. To skupaj je pomagalo algoritmu, da je manj časa iskal dejanske poti in več časa iskal dobre poti, vendar so se v rešitvi še vedno pojavile povezave, ki ne obstajajo. 